emulate -LR zsh -o noshortloops -o warncreateglobal -o extendedglob
zmodload -i zsh/zutil
autoload -Uz .hist.help

typeset -gHA _HIST__OPTS=(
  -f 'force:  do not ask for confirmation'
  -s 'silent: do not print anything'
)
typeset -gHA _HIST__ARGS=(
  d  'delete: remove from history'
  e  'edit:   remove from history, then modify & append as new'
  f  'fix:    remove from history, then load into buffer'
  l  'list:   look, but do not touch'
  r  'reload: re-initialize local history from file'
  u  'undo:   roll back to before last change in same session'
)

.hist.yes() {
  [[ -v opts[-f] ]] && return 0

  print -n "$1"
  read -q '? [y/n] '
  local ret=$?
  print -l
  return ret
}

hist() {
  emulate -LR zsh -o noshortloops -o warncreateglobal -o extendedglob

  local -A entries=() opts=()
  local HISTORY_IGNORE
  local REPLY

  zparseopts -D -A opts f i s v
  local act=$1 sel=$2

  if [[ $act != [${(j::k)_HIST__ARGS}] && ! -v opts[-s] ]]; then
    .hist.help
    return 1
  fi

  case $act in
    r)
      .hist.yes "Replace local history with contents of $HISTFILE?" &&
        builtin fc -p $HISTFILE $HISTSIZE $SAVEHIST
      return
      ;;
    u)
      if .hist.yes "Revert last 'hist' action & all entries since then?"; then
        builtin fc -P
        local ret=$?
        if ! [[ -v opts[-s] ]]; then
          if (( ret == 0 )); then
            print 'Revert successful. Previous history restored.'
          else
            print 'Unable to revert. No restore points available in this session.'
          fi
        fi
        return ret
      fi
      return
      ;;
  esac

  [[ -z $sel ]] && sel=-1

  if [[ -v history[${(b)sel}] ]]; then
    entries[$sel]=$history[$sel]
    HISTORY_IGNORE=${(b)history[$sel]}

    [[ -v opts[-s] ]] || builtin fc -l $sel $sel

  elif [[ -n ${(@kv)history[(r)$sel]} ]]; then
    entries=( "${(@kv)history[(R)$sel]}" )
    HISTORY_IGNORE=$sel

    [[ -v opts[-s] ]] || builtin fc -lm $sel 1 -1

  elif builtin fc -ln $sel $sel &> /dev/null; then
    local entry=$(builtin fc -ln $sel $sel)
    local full=$(builtin fc -l $sel $sel)
    local -i number=${full%%$entry}
    entries[$number]=$entry
    HISTORY_IGNORE=${(b)history[$number]}

    [[ -v opts[-s] ]] || print $full

  fi

  if (( $#entries == 0 )); then
    [[ -v opts[-s] ]] || print "No matching history entries found."
    return 1
  fi

  if [[ $act != [l] ]]; then
    local msg
    case $act in
      e)
        msg="Merge the ${#entries} entries above for editing?"
        ;;
      *)
        msg="Delete the ${#entries} entries above from history?"
        ;;
    esac
    if .hist.yes $msg; then
      builtin fc -W
      builtin fc -p $HISTFILE $HISTSIZE $SAVEHIST
      [[ -v opts[-s] ]] || print "${#entries} entries deleted."
    else
      [[ -v opts[-s] ]] || print '0 entries deleted.'
      return 1
    fi
  fi

  case $act in
    e)
      autoload -Uz zed

      bindkey -M zed &> /dev/null || zed -b
      bindkey -M zed '^[^M' accept-line
      if [[ ! -v opts[-s] ]]; then
        print -l
        print "Press Alt-Enter to save new entry and exit editor."
        print -l
      fi
      local file=$(mktemp)
      print -l ${(v)entries} > $file

      setopt NO_warncreateglobal
      zed $file
      setopt warncreateglobal

      print -s $(< $file)
      builtin fc -W
      [[ -v opts[-s] ]] && print -l && print "New entry saved."
      ;;
    f)
      print -z ${(v)entries}
      ;;
  esac
}

hist "$@"
